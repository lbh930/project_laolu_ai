/*
 * SPDX-FileCopyrightText: Copyright (c) 2024 - 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#pragma once

#include "CoreMinimal.h"

// engine includes
#include "Async/ManualResetEvent.h"
#include "Components/SceneComponent.h"
#include "Containers/Queue.h"
#include "Containers/RingBuffer.h"
#include "Containers/StaticArray.h"
#include "Generators/AudioGenerator.h"
#include "Sound/SoundAttenuation.h"
#include "Templates/UniquePtr.h"

// plugin includes
#include "AnimDataConsumer.h"

#include "ACEAudioCurveSourceComponent.generated.h"


enum ESoundGroup : int;
class FSoundSource;
class UAudioComponent;
class USoundAttenuation;
class USoundWave;
class USoundWaveProcedural;

/*
UENUM(BlueprintType)
enum class EAnimationEvent : uint8
{
	AE_Started,
	AE_Ended,
	AE_Aborting
};

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnAnimationEventDelegate,EAnimationEvent,AnimationEvent);
*/

DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnAnimationStartedDelegate);
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnAnimationEndedDelegate);



/** Plays audio received from ACE, and provides synchronized curves to drive animation */
UCLASS(meta = (BlueprintSpawnableComponent, DisplayName = "ACE Audio Curve Source"))
class ACERUNTIME_API UACEAudioCurveSourceComponent : public USceneComponent, public IACEAnimDataConsumer
{
	GENERATED_BODY()

public:
	UACEAudioCurveSourceComponent();
	UACEAudioCurveSourceComponent(FVTableHelper& Helper);
	virtual ~UACEAudioCurveSourceComponent();

	/** How many seconds of received audio to buffer before beginning playback */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ACE Config")
	float BufferLengthInSeconds = 0.1f;

	/** When "au.3dVisualize.Attenuation" has been specified, draw this sound's attenuation shape when the sound is audible. For debugging purposes only. */
	UPROPERTY(EditAnywhere, Category = Developer)
	uint8 bEnableAttenuationDebug : 1;

	/** Allows defining attenuation settings directly on this audio component without using an attenuation settings asset. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Attenuation)
	uint8 bOverrideAttenuation:1;

	/** If bOverrideAttenuation is false, the asset to use to determine attenuation properties for sounds generated by this component */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Attenuation, meta = (EditCondition = "!bOverrideAttenuation", DisplayAfter = "bOverrideAttenuation", EditConditionHides))
	TObjectPtr<USoundAttenuation> AttenuationSettings;

	/** If bOverrideAttenuation is true, the attenuation properties to use for sounds generated by this component */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Attenuation, meta = (EditCondition = "bOverrideAttenuation", DisplayAfter = "bOverrideAttenuation", EditConditionHides))
	FSoundAttenuationSettings AttenuationOverrides;

	/** Sound group to use for ACE-generated audio (Default: Voice) */
	UPROPERTY(EditAnywhere, Category = Sound, meta = (DisplayName = "Group"))
	TEnumAsByte<ESoundGroup> SoundGroup;


	UPROPERTY(BlueprintAssignable)
	FOnAnimationStartedDelegate OnAnimationStarted;

	UPROPERTY(BlueprintAssignable)
	FOnAnimationEndedDelegate OnAnimationEnded;

	/* To be implemented
	UPROPERTY(BlueprintAssignable)
	FOnAnimationEventDelegate OnAnimationEvent;
	*/

	/** Used to determine whether sound can play or remain active if channel limit is met, where higher value is higher priority
	  * (see platform's Audio Settings 'Max Channels' property). Unless bypassed, value is weighted with the final volume of the
	  * sound to produce final runtime priority value.
	  */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Voice Management|Priority", meta = (ClampMin = "0.0", UIMin = "0.0", ClampMax = "100.0", UIMax = "100.0"))
	float Priority;

	/** Playback volume of sound 0 to 1 - Default is 1.0. */
	UPROPERTY(Category = Sound, meta = (ClampMin = "0.0", ClampMax = "1.0"), EditAnywhere)
	float Volume;

	void BeginDestroy() override;

public:
	/** Curve (blend shape) names, in the same order as weights written by GetCurveWeights */
	static const FName CurveNames[55];

	/** Fetch all the curve weights for the current playback time */
	void GetCurveOutputs(TArray<float>& OutWeights);
	void GetCurveOutputsInterp(TArray<float>& OutWeights);

	/** Stop audio and animation */
	void Stop();

	// IACEAnimDataConsumer interface
	virtual void PrepareNewStream_AnyThread(int32 StreamID, uint32 SampleRate, int32 NumChannels, int32 SampleByteSize) override;
	virtual void ConsumeAnimData_AnyThread(const FACEAnimDataChunk& Chunk, int32 SessionID) override;

	// ActorComponent interface
	/** Tick so that we can do stuff that needs to run on game thread */
	virtual void TickComponent(float DeltaTime, enum ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

private:
	// audio data protected by CS
	uint64 ReceivedAudioSamples;
	UPROPERTY()
	TObjectPtr<UAudioComponent> AudioComponent;
	int32 TotalUnderflowSamples;
	FCriticalSection AudioCompCS;

	UE::FManualResetEvent AudioCompReady;

	// thread-safe curve generation data and session ID
	std::atomic<int32> ReceivedBSWeightSamples;
	struct FBSWeightSample {
		TArray<float> Weights;
		float Timestamp;
		int32 SessionID;
	};
	TQueue<FBSWeightSample, EQueueMode::Mpsc> BSWeightSampleQueue;
	std::atomic<int32> CurrentSessionID;
	TOptional<double> FirstACETimestamp;

	// game thread data
	TRingBuffer<FBSWeightSample> BSWeightSamples;
	int32 LastSampleIdx;
	int64 LastUpdatedGlobalTime;
	float AudioPlaybackTimeEstimate;
	float CurrentPlaybackTime;
	float LastAnimPlaybackTime;
	static const uint32 NUM_RECENT_PLAYBACK_TIMES = 20;
	TStaticArray<float, NUM_RECENT_PLAYBACK_TIMES> RecentPlaybackTimes;
	uint32 RecentPlaybackIdx = 0;

	enum class EAnimState : int32
	{
		// no current animation/audio
		IDLE,
		// animation/audio has been received but we haven't started it playing yet
		STARTING,
		// we've started audio playing
		STARTED,
		// audio playback in progress
		IN_PROGRESS,
		// end of animation has been reached
		ENDING,
	};
	std::atomic<EAnimState> AnimState{ EAnimState::IDLE };
	std::atomic_bool bAnimationAllFramesRecived;
	std::atomic<float> AudioSampleRate;
	std::atomic<int32> NumAudioChannels;
	std::atomic<int32> AudioSampleByteSize;
	// audio thread data
	//const FWaveInstance* CachedWaveInstance;

private:
	UAudioComponent* CreateAudioComponent_GameThread(uint32 SampleRate, int32 NumChannels, int32 SampleByteSize);
	void HandlePlaybackFraction(const UAudioComponent* InComponent, const USoundWave* InSoundWave, const float InPlaybackFraction);
	void HandleSoundUnderflow(USoundWaveProcedural* InProceduralWave, int32 SamplesRequired);
	const int32 GetCurrentSampleIdx();
	void EvaluateAndUpdateCurrentPlaybackTime();
	void PrepareNewAudioComponent_GameThread(int32 StreamID, uint32 SampleRate, int32 NumChannels, int32 SampleByteSize);
	const FSoundSource* FindSoundSourceAudioThread(const USoundWaveProcedural* SoundWave);
	bool IsAnimationActive() const { return AnimState != EAnimState::IDLE && AnimState != EAnimState::ENDING; }
	bool IsPlaybackActive() const { return AnimState == EAnimState::STARTED || AnimState == EAnimState::IN_PROGRESS; }
	void ResetAnimSamples();
};

